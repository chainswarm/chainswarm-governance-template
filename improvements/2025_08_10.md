# Chainswarm KOTH Subnet — Design Summary (Monorepo, GitHub‑First)

*Last updated: 2025‑08‑10 (Europe/Warsaw)*

## One‑paragraph abstract

A “King‑of‑the‑Hill” Bittensor subnet where **miners compete by shipping merged GitHub PRs** against owner‑defined requirements. **Only merged PRs in the weekly epoch count**. Validators don’t judge with LLMs—they **recompute scores from CI artifacts** (deterministic) and publish weights. Everything runs in a **single monorepo** with GitHub Actions: requirements, miner registry, weekly snapshots, and weight computation. An optional **Service Miner** earns a small, SLA‑based slice for keeping infra running.

---

## Design goals

* **Stupid‑simple workflow** (owner, miners, validators know exactly what to do).
* **Reproducible & objective** (no LLM scoring; artifact‑driven).
* **Weekly rhythm** (sprint‑like cadence, protected review window).
* **Anti‑gaming** (freeze, draft deadline, similarity guard, one PR per requirement per miner).
* **GitHub‑first** (no node software for miners; minimal validator code).

---

## Roles

* **Subnet Owner (final say):** publishes requirements (R‑IDs), reviews, merges; may pause epochs; defines priorities/effort tiers; can enable auto‑merge per requirement.
* **Miners:** register GitHub ↔ hotkey once; implement a requirement via **one PR per requirement per epoch**; include hotkey+signature in PR body; keep CI green.
* **Validators (mechanical):** fetch weekly snapshot of merged PRs, read CI artifacts, compute scores, and publish weights for the next week.
* **Service Miner (optional, non‑competing):** receives a small fixed slice if infra SLA is met; transparent and auditable.

---

## Monorepo, source of truth

Single repo contains everything:

```
repo-root/
  .github/workflows/   # CI + lifecycle + weights + registry checks
  requirements/        # R-#####.yaml with value/effort/perf flags
  registry/miners/     # {github}.yaml GitHub ↔ hotkey (signed)
  snapshots/{epoch}/   # frozen koth-score.json copies
  service_sla/{epoch}.json
  tools/validator.py   # deterministic scorer
  weights/{epoch}.json # final emission vector output
  (code packages live alongside)
```

Why monorepo: one place to automate epochs, snapshots, and weights; dead‑simple validator implementation and audit trail (Git history).

---

## Epoch schedule (Europe/Warsaw)

* **Build:** **Mon 00:00 → Fri 18:00** — miners code.
* **Freeze:** **Fri 18:00** — any pushes after roll the PR to **next epoch** (label `rolled:next-epoch`).
* **Owner review window:** Fri 18:00 → Sun 18:00 — owner reviews/comments/merges.
* **Snapshot:** **Sun 18:00** — governance workflow collects **merged** PR artifacts into `snapshots/{epoch}/`.
* **Weights compute:** **Sun 18:10** — validator script writes `weights/{epoch}.json`; weights apply the following week.
* **Epoch ID:** ISO year+week in Warsaw time, e.g., `2025‑W33`.

Draft safeguard (optional): PR must exist & be green by **Thu 18:00** to avoid last‑minute sniping; late first‑time PRs auto‑roll.

---

## Workflow (end‑to‑end)

1. **Owner** posts/updates requirements under `requirements/R‑#####.yaml` with:

   * `value:` **Low | Med | High | Critical** (business value)
   * `effort:` **XS | S | M | L | XL** (estimated effort)
   * `perf_enabled:` true|false (if a perf harness is expected)
   * (Optional) human‑readable acceptance checklist.
2. **Miner** registers once: adds `registry/miners/{github}.yaml` containing `{github, hotkey_ss58, nonce, signature_b64}` where the signature is **ed25519 over `nonce || hotkey_ss58`**, produced by `tools/generate_registry_entry.py`.
3. **Miner** opens a PR targeting a specific **R‑ID**, includes **Hotkey+Nonce+Signature** in the PR body using the template. CI verifies signature, runs tests, coverage, lint, radon, optional perf harness, and emits **`koth-score.json`**.
4. **Owner** reviews and **merges the single best PR per requirement** they want to accept this epoch. **Only merged PRs count.**
5. **Governance workflow** snapshots merged PRs for the week and copies each PR’s `koth-score.json` into `snapshots/{epoch}/pr‑XXXX.json`.
6. **Validator** runs `tools/validator.py` → reads snapshot + registry + requirement meta → computes per‑miner scores and the **weight vector**. Output is committed to `weights/{epoch}.json`.
7. **Chain emission weights** (off‑chain or on‑chain adapter) read `weights/{epoch}.json` and set validator weights accordingly for the next week.

---

## Scoring (deterministic, artifact‑only)

Let requirement metadata define **W\_r** through a simple value×effort grid, then combine artifact signals:

**Priority/Effort weight**

```
W_r = ValueWeight × EffortWeight  (cap at 1.50)
ValueWeight:  Low 0.60 | Med 0.80 | High 0.95 | Critical 1.00
EffortWeight: XS  0.70 |  S  0.85 |   M 1.00 |   L 1.20 |   XL 1.50
```

**Per‑PR RequirementScore** (only for **merged** PRs):

```
RequirementScore = W_r × (0.50·S_spec + 0.20·S_quality + 0.20·S_tests + 0.10·S_perf)
  S_spec   : acceptance checks passed / total (from owner or CI harness)
  S_quality: lint/static & complexity/duplication deltas (ruff/radon)
  S_tests  : coverage delta vs base + e2e pass
  S_perf   : only if perf_enabled=true; normalize latency/throughput deltas
```

**Miner weekly score:** sum of their RequirementScores (across all their merged PRs that epoch).

**Emissions:** `softmax(scores / τ)` with **τ ≈ 0.5** (smooth distribution). Optional **Service Miner** slice is applied before final normalization (see below).

Rationale: `value×effort` prevents an easy Critical from overshadowing a long Low; signals are simple, auditable, language‑agnostic; everything comes from CI.

---

## Multi‑miner & tie policy

* Multiple miners may target the same requirement in an epoch, but **owner merges exactly one** (or marks requirement `multi‑merge` if they want several winners). Only merged PRs count.
* If a later alternative is objectively better, the owner merges it in a **later epoch**—that miner wins then. This avoids “better‑but‑unmerged” debates.
* **Similarity guard (85%)** warns on near‑duplicate PRs to the same R‑ID to discourage copycat sniping; owner still chooses the merge.
* **One PR / requirement / miner / epoch** enforced by CI/bot (extra PRs auto‑closed or labelled).

---

## Anti‑gaming & eligibility

* **Hard fails:** failing CI; missing R‑ID; invalid signature; secrets or license violations; code‑touching PRs with clearly negative test deltas unless explicitly labelled doc‑only.
* **Freeze:** pushes after Fri 18:00 mark PR `rolled:next‑epoch`.
* **(Optional) Draft deadline:** PR must exist & be green by Thu 18:00; new PRs after that auto‑roll.
* **LOC quality window** (suggested): large dumps and pure re‑format PRs score poorly via quality/test signals.

---

## Service Miner (cover infra fairly)

* **Non‑competing** address; cannot submit feature PRs.
* Weekly file `service_sla/{epoch}.json`:

  ```json
  { "hotkey": "5F...service", "service_score": 0.96, "budget": 0.075 }
  ```
* Validators allocate **budget × service\_score** (capped; default threshold ≥0.8). Remaining emission mass is scaled across miners via softmax weights.
* SLA evidence (uptime, alerts, quorum attestations) can be attached under `service_sla/` or a separate dashboard.

---

## Identity & registration (GitHub ↔ hotkey)

* Miners add `registry/miners/{github}.yaml` with:

  ```yaml
  github: your-handle
  hotkey_ss58: 5Fabc...
  nonce: <32 bytes hex>
  signature_b64: <ed25519 over (nonce || hotkey_ss58)>
  ```
* Use `tools/generate_registry_entry.py` (Bittensor wallet) to produce fields. CI verifies on PR.
* **Rewards require registration merged before Sunday 18:00.** Unregistered authors can be merged but won’t receive emissions that week.

---

## Validator program (tools/validator.py)

* Inputs: `snapshots/{epoch}/pr-*.json`, `requirements/`, `registry/miners/`, optional `service_sla/{epoch}.json`.
* For each PR JSON, map `miner_github` → hotkey (prefer artifact hotkey, fallback to registry mapping), read requirement meta, compute `RequirementScore`.
* Aggregate per hotkey; apply softmax with τ; mix in Service Miner share if present; normalize; write `weights/{epoch}.json`.
* Any validator can recompute independently; Git history + artifacts are auditable.

---

## GitHub Actions (stack)

* **koth‑ci.yml (Python)** — runs on PR events; installs deps; pytest+coverage; ruff; radon; optional perf harness; verifies signature; emits `koth-score.json`.
* **epoch‑lifecycle.yml** — hourly tick; labels PRs by epoch; at Sun 18:00 collects merged PRs’ artifacts into `snapshots/{epoch}/` and commits snapshot.
* **compute‑weights.yml** — Sun 18:10; runs `tools/validator.py`; commits `weights/{epoch}.json`.
* **registry‑verify.yml** — validates signatures in `registry/miners/*.yaml` on PR.
* **(Optional) sync‑labels.yml** — seeds standard labels (`priority:*`, `perf:harness`, `rolled:next-epoch`, `verified`).
* **(Optional) similarity‑guard.yml** — warns when two open PRs for the same R‑ID look highly similar.

---

## Holidays / pauses / zero‑miner weeks

* **Pause switch:** repo variable `SUBNET_PAUSED=true` → lifecycle writes a paused snapshot (policy: burn or 1× carry‑forward; default **burn** to avoid subsidizing inactivity).
* **Zero merged PRs:** miner weights 0 (burn). Service Miner may still earn its SLA share if active.
* **Delegation:** team `@subnet‑maintainers` in `CODEOWNERS` can merge during owner absence.

---

## Security & compliance notes

* Signature scheme is **ed25519 over `nonce || hotkey_ss58`**; CI verifies with Polkadot utils.
* Keep wallet ops **local**; never paste private keys. The helper script only signs the message.
* CI secrets minimal; use least‑privilege permissions; consider CodeQL/SAST as a non‑scoring advisory.

---

## Rationale & trade‑offs (brief)

* **Merged‑only wins** keeps arbitration simple and aligned with maintainers.
* **Owner final say** avoids validator subjectivity and LLM drift.
* **Value×Effort grid** lets long Lows fairly compete with easy Criticals.
* **Softmax** prevents cliffy winner‑take‑all and smooths emissions.
* **Monorepo** provides a single, auditable ledger of snapshots and weights.

---

## Open knobs (can change later)

* Softmax temperature **τ** (default 0.5).
* Service Miner **budget** (default 7.5%) and **threshold** (default 0.8).
* Similarity guard threshold (default 85%).
* Draft deadline enforcement (Thu 18:00) on/off.
* Additional scoring terms if needed (e.g., docs coverage signal).

---

## Quick references (filenames)

* PR template: `.github/PULL_REQUEST_TEMPLATE.md`
* Miner generator: `tools/generate_registry_entry.py`
* Metrics helper: `tools/compute_koth_metrics.py`
* Validator: `tools/validator.py`
* CI: `.github/workflows/koth-ci.yml`
* Epoch lifecycle: `.github/workflows/epoch-lifecycle.yml`
* Weights compute: `.github/workflows/compute-weights.yml`
* Registry verify: `.github/workflows/registry-verify.yml`

---

## TL;DR for a new participant

1. Read requirements under `requirements/` and pick an **R‑ID**.
2. Register once under `registry/miners/` (use the Python helper to sign).
3. Open **one PR** for that R‑ID, paste **hotkey + nonce + signature**; keep CI green.
4. If the owner **merges** your PR before Sunday 18:00 (Warsaw), you’ll be scored this epoch.
5. Weights are published Sunday 18:10 → emissions flow next week.
